<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"/><meta name="theme-color" content="#222"/><meta http-equiv="X-UA-COMPATIBLE" content="IE=edge,chrome=1"/><meta name="renderer" content="webkit"/><link rel="icon" type="image/ico" sizes="32x32" href="/assets/favicon.ico"/><link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png"/><link rel="alternate" href="/rss.xml" title="这就是--Potato" type="application/rss+xml"><link rel="alternate" href="/atom.xml" title="这就是--Potato" type="application/atom+xml"><link rel="alternate" type="application/json" title="这就是--Potato" href="https://zhewanyiershinicheng.github.io/feed.json"/><link rel="preconnect" href="https://s4.zstatic.net"/><link rel="preconnect" href="https://at.alicdn.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7CFredericka%20the%20Great:400,400italic,700,700italic%7CNoto%20Serif%20JP:400,400italic,700,700italic%7CNoto%20Serif%20SC:400,400italic,700,700italic%7CInconsolata:400,400italic,700,700italic&display=swap&subset=latin,latin-ext" media="none" onload="this.media&#x3D;&#39;all&#39;"><link rel="stylesheet" href="/css/app.css?v=0.4.17"><link rel="modulepreload" href="/js/chunk-4WOL5AEA.js"></link><link rel="modulepreload" href="/js/chunk-M2OVB55D.js"></link><link rel="modulepreload" href="/js/chunk-OEHKNEWL.js"></link><link rel="modulepreload" href="/js/copy-tex-JCSSB3EK.js"></link><link rel="modulepreload" href="/js/index.esm-H3NZFZ46.js"></link><link rel="modulepreload" href="/js/post-RFOLAXHH.js"></link><link rel="modulepreload" href="/js/quicklink-LPV2RIEA.js"></link><link rel="modulepreload" href="/js/siteInit.js"></link><link rel="preload" href="6833939bly1giciszlczyj20zk0m816d.jpg" as="image" fetchpriority="high"><link rel="preload" href="6833939bly1gicitcxhpij20zk0m8hdt.jpg" as="image" fetchpriority="high"><link rel="preload" href="6833939bly1gicis3attqj20zk0m8k7l.jpg" as="image" fetchpriority="high"><link rel="preload" href="6833939bly1gicit31ffoj20zk0m8naf.jpg" as="image" fetchpriority="high"><link rel="preload" href="6833939bly1giciryrr3rj20zk0m8nhk.jpg" as="image" fetchpriority="high"><link rel="preload" href="6833939bly1gicit4jrvuj20zk0m8785.jpg" as="image" fetchpriority="high"><meta name="keywords" content="《舰舰的奇妙冒险》"/><meta name="description" content="挤牙膏式升级！！！！！"/><link rel="canonical" href="https://zhewanyiershinicheng.github.io/2024/10/14/C%E7%AC%94%E8%AE%B01ultrasuper/"><title>C笔记ultra</title><meta name="generator" content="Hexo 7.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">C笔记ultra</h1><div class="meta"><span class="item" title="作成日：2024-10-14 13:21:05"><span class="icon"><i class="ic i-calendar"></i></span><span class="text">投稿日</span><time itemprop="dateCreated datePublished" datetime="2024-10-14T13:21:05+08:00">2024-10-14</time></span><span class="item" title="単語数"><span class="icon"><i class="ic i-pen"></i></span><span class="text">単語数</span><span>22k</span><span class="text">単語</span></span><span class="item" title="読書の時間"><span class="icon"><i class="ic i-clock"></i></span><span class="text">読書の時間</span><span>20 分</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="ナビゲーションバーの切り替え"><span class="line"></span><span class="line"></span><span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">chongkai</a></li></ul><ul class="right" id="rightNav"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div class="pjax" id="imgs"><img src="https://7ed.net/bing/api" loading="eager" decoding="async" fetchpriority="high" alt="这就是--Potato"></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"></use><use xlink:href="#gentle-wave" x="48" y="3"></use><use xlink:href="#gentle-wave" x="48" y="5"></use><use xlink:href="#gentle-wave" x="48" y="7"></use></g></svg></div><main><div class="inner"><div class="pjax" id="main"><div class="article wrap"><div class="breadcrumb" itemListElement itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i><span><a href="/">ホーム</a></span><i class="ic i-angle-right"></i><span class="current" itemprop="itemListElement" itemscope="itemscope" itemtype="https://schema.org/ListItem"><a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="item" rel="index" title="カテゴリ技术"><span itemprop="name">技术<meta itemprop="position" content="0"/></span></a></span></div><article class="post block" itemscope="itemscope" itemtype="http://schema.org/Article" lang="zh-cn"><link itemprop="mainEntityOfPage" href="https://zhewanyiershinicheng.github.io/2024/10/14/C%E7%AC%94%E8%AE%B01ultrasuper/"/><span hidden="hidden" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="image" content="/assets/avatar.jpg"/><meta itemprop="name" content="开船的"/><meta itemprop="description" content="真的假的？, bug依旧很多，反正我忍不了"/></span><span hidden="hidden" itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="这就是--Potato"/></span><div class="body md" itemprop="articleBody"><h1 id="i语法"><a class="anchor" href="#i语法">#</a> Ⅰ. 语法（？）</h1>
<h4 id="一程序执行"><a class="anchor" href="#一程序执行">#</a> <strong>一。程序执行</strong></h4>
<ol>
<li>解释：由该程序执行操作（python）</li>
<li>编译：由该程序将语言翻译为机器语言，由编译出的程序执行操作（C）</li>
</ol>
<h4 id="二printf-与scanf-stdioh"><a class="anchor" href="#二printf-与scanf-stdioh">#</a> <strong>二.printf 与 scanf</strong>              <strong>&lt;stdio.h&gt;</strong></h4>
<p>\n 表示换行，如果要直接输出，输入 \\n 来转义</p>
<p>在写的程序中换行对编译器没有影响。</p>
<p>scanf 需要 &amp; a, 但是 printf 不需要 &amp;，double 在 scanf 中必须要用 % lf</p>
<p>scanf 里的非变量部分在输入时也必须输入，否则可能无法正确接收数据（空格为输入任意）</p>
<blockquote>
<p>%d(ld):	int(long long)</p>
<p>%f(lf):	float(double,longdouble)</p>
<p>% u:	unsigned long long     // 即使是其他类型，也可以用 % u 输出，注意 ：</p>
<p>% c:	字符串                              会自动扩展其他位，比如传入 - 1 就会使所有位的都                                    % e (E):	科学计数法                        变成 1（传入 printf 的补码 (@int 类型是这样的) )</p>
<p>//double ff=1E-10 也是可以的，就是 1 的负 10 次方，输出要确定保留位数（%.3/4/5lf），会四舍五入。</p>
<p>float/double 的表达是离散的，不连续，遇到不能准确表达的会就近选择（精度越高，能表达的数的间隔越小）## 见下</p>
</blockquote>
<p>#% d 其实时默认时 10 进制输出，不过输入可以是其他进制，会自动转化。</p>
<p><strong>% d 后面没有空格，是只读取到整数结束为止，其他留给下一个变量</strong></p>
<p><strong>如有，则会顺便读取整数结束后的所有空格个，这是特殊的，用于防止误读空格</strong></p>
<p>//% o：输出 8 进制（不会自带 0）</p>
<p>//% x（X）：输出 16 进制（不会自带 0x），x 的大小写决定了输出时的大小写（这点和 % e 一样）</p>
<p>16 进制两位就是一个字节（8bit）, 即一个 char，经常用于表答二进制 (方便变换)</p>
<p>8 进制是因为以前有 12 位的电脑，用 8 进制表达方便，现在一般用于单片机</p>
<h4 id="三关系运算"><a class="anchor" href="#三关系运算">#</a> 三。关系运算</h4>
<p><strong>运算符：</strong></p>
<p>+，-，/，*：略         // 当 +- 作为单目运算符时 (表示正负)，优先级最高且只能在后面。</p>
<p>%：取余                    // 要获取一个运算的整数部分，直接整数运算，要获得余数，则取余。</p>
<p>=：赋值                     // 在 C 中这是也是一个运算符有输出，唯一的自右向左。a=b=6 实际上是 a=(b=6)</p>
<p>​                                      也就是说 b=6 的输出值其实就是 6</p>
<blockquote>
<p>#可以一行定义多个同类型的变量用 &quot;,&quot; 隔开。</p>
<p>#不要嵌套赋值，belike:r=(r=r+3)*6*(r=r+4)</p>
</blockquote>
<h4 id="三五复合赋值"><a class="anchor" href="#三五复合赋值">#</a> <strong>三。五. 复合赋值</strong></h4>
<p>++/--（递增 / 递减，这属于单目运算符）</p>
<p>count++/-- 实际上是 count=count+/-1</p>
<p>前缀时 (++/--a): 此句就已经是 a+/-1</p>
<p>后缀时 (a++/--): 此句输出还是 a，此句结束后 a+/-1</p>
<h4 id="四变量与常量"><a class="anchor" href="#四变量与常量">#</a> <strong>四。变量与常量</strong></h4>
<p>变量类型一旦定义就无法改变            // 没有初始值时是乱码（原来内存里的不知道什么玩意儿）</p>
<p>常量一旦定义无法改变（const int）<em>// 通常全大写以区分</em></p>
<blockquote>
<p>#定义时可以有运算</p>
</blockquote>
<h4 id="五变量类型"><a class="anchor" href="#五变量类型">#</a> 五。变量类型</h4>
<h4 id="总起"><a class="anchor" href="#总起">#</a> 总起</h4>
<p>表示范围:char&lt;short&lt;int&lt;float&lt;double</p>
<p>输入输出时的格式化:% d，% ld，% lf</p>
<p>在内存中的大小：1 字节 (char)（8bit, 即 8 位），2 字节 (short)，4 字节 (int，long (32 位环境))，8 字节 (double，long (64 位环境)，long long)</p>
<p>//int 的大小其实也是不确定的，它等于电脑 CPU 的寄存器宽度（字长 (cpu 一次可以处理的数据长度) 以及<a href="%E5%8D%95%E6%AC%A1%E5%8F%AF%E4%BB%A5%E4%BC%A0%E8%BE%93%E7%9A%84%E9%95%BF%E5%BA%A6%EF%BC%8Ccpu%E4%B8%8E%E5%86%85%E5%AD%98%E4%B9%8B%E9%97%B4">总线</a>）</p>
<p>在内存中的表达形式：二进制数 (补码)(int)，编码 (浮点数都是)</p>
<p>//sizeof ()    用于输出该变量的所占字节数，不能在其中运算 (会被无视)，这是静态的：</p>
<pre><code>sizeof(a++)=sizeof(a)    //即使在后面printf(&quot;%d&quot;,a)输出也还是a而不是a+1
sizeof(a+1.0)//输出是8，因为整数和浮点数运算前会转换成浮点数，所以是浮点数的8
               这不意味着有进行运算，只是判断了最后还是double类型而已
</code></pre>
<h5 id="1整数int看编译器即一个字bool"><a class="anchor" href="#1整数int看编译器即一个字bool">#</a> 1. 整数（int (看编译器，即一个字)/bool）</h5>
<p><strong>一般用 int</strong></p>
<p>是有范围的，还有 short (-32768-32767)，long，long long int (C99)</p>
<p>// 如果读取到负数，处理时又不能带符号，最后还要输出。那么可以单独 printf 一个负号，然后 x=-=x</p>
<p>//bool 是人为定义的，它只存在于 C99，即布尔量</p>
<blockquote>
<p>整数的内部表达：</p>
<p>18-------00010010</p>
<p>三种方案：</p>
<p>1. 特殊标志（用第一位为 1 来代表负数运算时遇 + 则 -，乘除保留或变 0）</p>
<p>2. 取中间数，即 1000000 表示 0，更大为正，反之为负</p>
<p>3. 补码（其实就是溢出丢掉从头再来 8bit 当进到下一位时，会舍弃第九位的 1）</p>
<p>11111111（255，当作补码时为 - 1，因为 + 1=0）这样的好处是可以直接运算</p>
<p>// 对于二进制一个数的补码是 2&lt;sup&gt;n&lt;/sup&gt;-1</p>
</blockquote>
<p>对于一个字节的变量（char）：</p>
<p>000000000：0</p>
<p>111111111-10000000=-1~-128（补码）</p>
<p>000000001<sub>01111111=1</sub><strong>127</strong>（少一位是因为 0 也要占一个表示方法，一共 2&lt;sup&gt;n&lt;/sup&gt;）</p>
<p>// 由于 - 128 与 127 在二进制的表示上是连在一起的，所以：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> a<span class="token operator">=</span><span class="token operator">-</span><span class="token number">128</span></pre></td></tr><tr><td data-num="2"></td><td><pre>a<span class="token operator">-=</span><span class="token number">1</span>                  <span class="token comment">// 此时输出的 a=127</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">char</span> b<span class="token operator">=</span><span class="token number">127</span></pre></td></tr><tr><td data-num="4"></td><td><pre>b<span class="token operator">+=</span><span class="token number">1</span>                  <span class="token comment">// 此时输出 b=-128</span></pre></td></tr></table></figure><p>这个循环是：</p>
<p>-1<sub>0</sub>......<sub>127</sub>-128<sub>......-1</sub>0</p>
<p>对于 unsigned char:</p>
<p>0-255-0-255</p>
<p>布尔类型 (bool)</p>
<p>需要 #include&lt;stdbool.h&gt;, 但实际上不会输出所谓的 true 或者 false, 本质上还是 1/0</p>
<hr />
<h5 id="2浮点数floatdouble"><a class="anchor" href="#2浮点数floatdouble">#</a> 2. 浮点数（float,double）</h5>
<p>一般用 double</p>
<p>** 精确计算不能使用浮点数！！！** 只能用整型或者 bcd 码</p>
<blockquote>
<p>这种码只用 4bit（2^4=16）, 也只表示 0~9, 它通过拼凑来得到数字，由于是表示 10 进制数，二进制运算时的结果可能要修正， 修正的规则是：当两个 BCD 码相加，如果和等于或小于 1001（10 进制的 9），无需修正。如果相加之和在 1010 到 1111 (即十六进制数 0AH～0FH) 之间，则需加 6 进行修正；如果相加时，本位产生了进位，也需加 6 进行修正。这样做的原因是，机器按二进制相加，所以 4 位 [二进制数相加时，是按 &quot;逢十六进一&quot; 的原则进行运算的，而实质上是 2 个十进制数相加，应该按 &quot;逢十进一&quot; 的原则相加，16 与 10 相差 6，所以当和超过 9 或有进位时，都要加 6 进行修正。</p>
</blockquote>
<p>可以表示 +/-inf（无穷大 / 小，实际上是越界无法表达），nan（无效数字，比如 0/0，如果用整数，会报错，而浮点不会，只会输出 nan）</p>
<p>带小数部分，有 longdouble（C99）</p>
<p>float (4 字节，字长 32)：<strong>有效数字</strong> 7 位，在 0 周围 10&lt;sup&gt;-38&lt;/sup &gt; 里无法表示</p>
<p>double (8 字节，字长 64)：<strong>有效数字</strong> 15 位，在 0 周围 10&lt;sup&gt;-308&lt;/sup &gt; 里无法表示</p>
<p>// 浮点数中的 0 是单独拿出来表示的</p>
<p>浮点数的运算精度 (## 见上):</p>
<p>在运算超出 float 范围时，编译器会强制将其转换为 double，如果不想要这样，在数字后加 f</p>
<pre><code>flaot a=1.345f
</code></pre>
<p><strong>保留位数会影响结果，因为精度的问题，如果保留位数少，可能四舍五入后还是正确的，但是如果多起来，就会有误差。（注意，实际上内存中的就是不精确的，改变保留位数只是我们自己看的而已 ）</strong></p>
<hr />
<blockquote>
<p>浮点数的内部表达：</p>
<p>1bit 用于表达正负</p>
<p>11bit 用于表达指数部分</p>
<p>剩下的都是分数部分和其他没有利用的部分</p>
<p>浮点计算是由专用硬件负责的</p>
</blockquote>
<hr />
<h5 id="3字符char"><a class="anchor" href="#3字符char">#</a> 3. 字符（<a href="-128-127">char</a>）</h5>
<p><strong>也可以是整数类型</strong>，不一定都是字符（没有 “” 的话）</p>
<blockquote>
<p>#字符串不能参与和整数或者浮点数的运算。</p>
</blockquote>
<p>C 中使用 ASCII 编码所以：49=‘1’</p>
<p>字符加 n，就直接得到它后面第 n 个字符。</p>
<p>两个字符相减，可以得到它们之间的距离。</p>
<blockquote>
<p><strong>a+'a'-'A' 可以将大写转化为小写</strong></p>
<p><strong>a+'A'-'a' 可以将小写转化为大写</strong></p>
</blockquote>
<p>逃逸字符（\）：</p>
<p>\b : 回退一格，实际上是回去，但是不删除（这取决于终端），但是会用后面直接连接的字符覆盖它（该字符不会再次输出）</p>
<p>\t : 到下一个表格位（直接到下一个固定位置）</p>
<p>\n,\r : 换行，回车，这来自于早期打字机，到现在，没什么区别</p>
<p>getchar (): 读入一个字符，返回一个 intEOF (-1)，表示结束</p>
<p>使用 Crtl + C 强制结束</p>
<p>使用 Crtl + D (UNIX)/Z (WIN) 结束并输出 EOF</p>
<blockquote>
<p>用户的直接输入实际上都在 shell 的缓冲区，程序运行时根据函数读取缓冲区中的数据 getchar 和 scanf 读取长度时不一样的（这也解释了为什么超出会顺延下去），这个缓冲区会有暂停的地方（用于等待你输入），如果使用了上面的快捷键，那么 shell 才会真正给出停止信号，给出 EOF</p>
</blockquote>
<h6 id="杂项"><a class="anchor" href="#杂项">#</a> 杂项</h6>
<hr />
<p>#整数之间的运算会直接舍弃所有小数部分，在计算过程中也是，但是整数与浮点数运算时，</p>
<hr />
<p><strong>整数会被转化为浮点数参与运算</strong>                // 但它还是整数，有时还会特意乘 1.0 来转化</p>
<p>​                                                                        (不如直接 double)</p>
<hr />
<p>// 初始化时，浮点数应是 0.0</p>
<p><strong>如果想要被当作纯二进制来看待，要写为：unsigned char（即不用补码）</strong></p>
<p><strong>这样表示范围就会变成 0~255，但是，此时不能表达负数</strong></p>
<p>EX1. 断点</p>
<p>断点的一行是未被执行的。可以将鼠标移动到变量上查看此时该变量的值。  // 要调试运行</p>
<p>EX2. 交换变量（a,b）</p>
<p>t=a,a=b,b=t</p>
<p>// 整数类型除法会直接舍弃小数，可以用于整数求逆</p>
<h5 id="4指针单独放在下面"><a class="anchor" href="#4指针单独放在下面">#</a> 4. 指针（单独放在下面）</h5>
<h5 id="5自定义类型"><a class="anchor" href="#5自定义类型">#</a> 5. 自定义类型</h5>
<h6 id="枚举"><a class="anchor" href="#枚举">#</a> 枚举</h6>
<p>用于定义一些名字，而不用 const int 来：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">enum</span> 枚举类型名字，可不写<span class="token punctuation">&#123;</span>名字<span class="token number">0</span>，名字<span class="token number">1.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>，Number<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 这些都是常量，操作时默认 int 且从 0 开始 (所以后的 number 就真的是这个枚举的有效数量，有个套路，见下),enum 本身不是一种变量类型（但是本质上是 int），它是声明一种变量类型</span></pre></td></tr><tr><td data-num="3"></td><td><pre>要更改数值</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">a</span><span class="token punctuation">&#123;</span>RED<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>YELLOW<span class="token punctuation">,</span>GREEN<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>NumCOLORS<span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">enum</span> <span class="token class-name">color</span> <span class="token punctuation">&#123;</span>red<span class="token punctuation">,</span>yellow<span class="token punctuation">,</span>green<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">color</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 使用这个类型时，前面要加 enum（C++ 不用）</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span>viod<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">enum</span> <span class="token class-name">color</span> t<span class="token operator">=</span>red<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span>，<span class="token operator">&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token function">f</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    </pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">color</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span>	<span class="token comment">// 输出还是 1</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>自动计数的枚举：</p>
<p><img loading="lazy" data-src="1729513141155.png" alt="1729513141155" /></p>
<p>0 这里也能看出，实际上枚举很少作为类型使用，它作用在于：</p>
<ol>
<li>
<p>枚举可以为一组整数常量赋予有意义的名称，使得代码更易于理解。例如，用 <code>enum Weekday &#123;MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY&#125;;</code>  定义了一周的天数。在代码中使用 <code>MONDAY</code>  比直接使用数字 0（假设周一被映射为数字 0）更直观地表示星期一，提高了代码的可读性和可维护性。</p>
</li>
<li>
<p>通过枚举定义的变量只能取枚举中定义的特定值，编译器可以在编译时进行类型检查，防止意外地为变量赋予不合法的值。例如，如果定义了一个枚举类型 <code>enum Color &#123;RED, GREEN, BLUE&#125;</code> ，那么一个声明为该枚举类型的变量就只能被赋值为 <code>RED</code> 、 <code>GREEN</code>  或 <code>BLUE</code>  这三个值之一，而不能被赋予其他任意整数值。</p>
</li>
<li>
<p>集中管理常量：</p>
<p>当有一组相关的常量需要在程序中多处使用时，使用枚举可以将这些常量集中定义在一处，便于管理和修改。如果需要修改某个常量的值，只需要在枚举定义处进行修改，而不需要在代码中逐个查找和修改使用该常量的地方。</p>
<p>例如，如果要修改表示一周中某一天的常量值，只需要在枚举定义中修改相应的枚举值，而不需要在整个程序中搜索并修改所有使用该常量的地方。</p>
</li>
<li>
<p>易于扩展：</p>
<p>如果需要在现有枚举中添加新的常量，只需要在枚举定义中添加新的枚举值即可，不会影响到已有的代码逻辑。例如，在 <code>enum Color &#123;RED, GREEN, BLUE&#125;</code>  的基础上，如果需要添加一个新的颜色 <code>YELLOW</code> ，只需要将枚举定义修改为 <code>enum Color &#123;RED, GREEN, BLUE, YELLOW&#125;</code> ，而使用该枚举的代码无需进行大规模修改。</p>
</li>
</ol>
<h6 id="结构体"><a class="anchor" href="#结构体">#</a> 结构体</h6>
<p>格式：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> 标签 <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">char</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">float</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>（其他有效变量定义，也可以是其他结构体）</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span>  结构变量（可以不只定义一个）<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 一般三者至少出现俩</span></pre></td></tr></table></figure><p>互相包含的结构体，要进行不完整声明：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token punctuation">;</span>    <span class="token comment">// 对结构体 B 进行不完整声明</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 结构体 A 中包含指向结构体 B 的指针</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">A</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">*</span>partner<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 结构体 B 中包含指向结构体 A 的指针，在 A 声明完后，B 也随之进行声明</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">B</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token operator">*</span>partner<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>即使两个结构体的成员一样，也会被当作两个不同的（前提是标签和结构变量要有不同）</p>
<p>使用：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token class-name">Simple</span> t1<span class="token punctuation">,</span> t2<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>t3<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 分别表示一个结构体，结构体数组，指向该结构体的指针</span></pre></td></tr><tr><td data-num="3"></td><td><pre>也就是说<span class="token operator">*</span>t3可以指向t1</pre></td></tr></table></figure><p>与 typedef 连用：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">char</span> b<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">double</span> c<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span> Simple2<span class="token punctuation">;</span>   <span class="token comment">// 注意，这里的 Simple2 是别称，结构体三者只出现了一个</span></pre></td></tr><tr><td data-num="7"></td><td><pre>Simple2 u1<span class="token punctuation">,</span>u2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">*</span>u3</pre></td></tr></table></figure><h5 id="ex"><a class="anchor" href="#ex">#</a> EX</h5>
<h6 id="ex整数求逆"><a class="anchor" href="#ex整数求逆">#</a> EX 整数求逆</h6>
<ul>
<li>
<p>如果 %10，会得到个位数</p>
</li>
<li>
<p>如果 / 10，会去掉个位数</p>
<p>当去掉一个个位数后，会有新的一个个位数（原来的十位数），可以再 %10 读取</p>
<p>C 中不会自动换行，所以 while 中直接 printf 出来，连起来的就刚好是逆向的</p>
<p>但是 0 在开头也会输出。如果不要，那么用 ret*=10+a (读取的数) 的循环顶位，再输出。（0*10=0, 所以在读取到第一位有效数字前的 0 不会被输出，在之后的则有 * 10 顶出个位来加）</p>
</li>
</ul>
<p>如果要正序且末尾有 0，那么只能使用 i-- 的方法，这需要知道是几位数。</p>
<p>这是不能判断原数字，而是那个 10&lt;sup&gt;n&lt;/sup&gt;,n 可以先用 / 那个数读取长度，这时要用 pow (), 当然。也可以在读取循环时顺便来个变量 * 10</p>
<p>// 这里使用 while 代替 do-while，虽然 mask 是对的（直接加会因为 do-while 的无条件执行一次而多 10 倍，当然，可以事后 / 10），但是读取后原数没了，所以有了 t</p>
<h6 id="ex类型转化"><a class="anchor" href="#ex类型转化">#</a> EX 类型转化</h6>
<p>所有的类型转化都只是在运算中，不会改变这个变量以及它本身的类型</p>
<p><strong>自动：</strong></p>
<p>当运算符两边不一致时，会自动传化为较大的类型:</p>
<p>char--short--int--long--long long</p>
<p>int--float--double</p>
<p>但是对于 printf（不包括 scanf）:</p>
<p>小于 int 都会变成 int</p>
<p>float 都会变成 double</p>
<p><strong>强制：</strong></p>
<p>优先级高于所有其他运算</p>
<p>(int) 32     // 注意安全性，不要越界</p>
<h4 id="六条件判断ifswitch"><a class="anchor" href="#六条件判断ifswitch">#</a> 六。条件判断（if/switch）</h4>
<h5 id="1if-else"><a class="anchor" href="#1if-else">#</a> 1.if-else</h5>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">></span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>代码<span class="token number">1</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>代码<span class="token number">2</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="6"></td><td><pre>代码<span class="token number">3</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>级联 if-else：</p>
<p>必需范围从大到小，因为实际执行的只有一个，而且顺序执行。</p>
<p>如果都要判断，要用多个 if（能不用就不用，会多次判断）</p>
<p>// 不同于 python，c 中的 if，else 都是就近匹配，不是依赖缩进，所以最好加上大括号</p>
<h5 id="2switch-case"><a class="anchor" href="#2switch-case">#</a> 2.switch-case</h5>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>         <span class="token comment">//type 必须是整数类型</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">case</span> 常量<span class="token operator">:</span>              <span class="token comment">// 这个常量可以是常数，也可以是常数计算的表达式</span></pre></td></tr><tr><td data-num="3"></td><td><pre>xxx                      C99中还可以用定义的常量</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">break</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">case</span> 常量<span class="token operator">:</span></pre></td></tr><tr><td data-num="6"></td><td><pre>xxx</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">break</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">default</span><span class="token operator">:</span>               <span class="token comment">// 当上述一个都没有时跳转</span></pre></td></tr><tr><td data-num="9"></td><td><pre>xxx</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">&#125;</span>                      <span class="token comment">// 这时相当于一个级联 if</span></pre></td></tr></table></figure><p>switch 本质上是一种跳转，如果不 break，会直接向下执行，而且</p>
<p>这种跳转只有一次，跳完后所以 case 都当作不存在。</p>
<p>（break 会直接跳出整个 switch）</p>
<p>ps：比较像批处理中的标签一样的玩意儿（？）</p>
<h4 id="七循环forwhile"><a class="anchor" href="#七循环forwhile">#</a> 七。循环 (for/while)</h4>
<h5 id="1while"><a class="anchor" href="#1while">#</a> 1.while</h5>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">while</span> <span class="token punctuation">(</span>条件<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>循环体                         </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">// 只要条件依然满足，就会循坏，不会执行下面的代码</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">//if 只有一次判断，而 while 有多次</span></pre></td></tr></table></figure><p>在调试时，可以随便在 while 中 printf 些什么，用于直观判断运行情况，最后记得注释掉就行。</p>
<p>数位数的算法：</p>
<p>1. 用户输入 x</p>
<p>2. 初始化 n=0</p>
<p>3.n++</p>
<p>4. 如果 x&gt;0，回到 3</p>
<p>5. 否则 n 为结果</p>
<p>// 一般来说，在进入 while 前，循环体要先执行一次，这样才会是 “循环”，这就是：</p>
<p>do-while 循环</p>
<pre><code>do
&#123;  
循环体
&#125;while(循环条件)；    //先执行一次，然后判断
//不要忘记封号          也可以说是先执行，再判断，while则反之
</code></pre>
<p>也就是说，do-while 至少执行一遍，while 可能一遍都不做</p>
<p>EX:rand () 可以召唤随机整数，使用方法：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;time.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">100</span><span class="token operator">+</span><span class="token number">1</span>   <span class="token comment">// 这使得数在 100 以内</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="2for"><a class="anchor" href="#2for">#</a> 2.for</h5>
<pre><code>
for (初始条件;循环条件;每轮动作)&#123;           //这个动作接到每次循环结尾
循环体                                   //i的值可以在初始化中定义
&#125;                                         但是只有C99才行，初始条件可以                                           省略           
</code></pre>
<p>循环可以有两种计数方式：</p>
<p>for (int i=0;i&lt;5;i++)   或者   for (int i=1;i&lt;=5;i++)   都是循环 5 次</p>
<p>for 循环实际上与 while 是一样的！！！任何 for 都可以改写成 while 循环 。</p>
<p><strong>// 如果是要固定次数的循环，那么用 for;</strong></p>
<p><strong>// 如果必需执行一次，就用 do-while 循环；</strong></p>
<p><strong>// 其他都用 while</strong></p>
<p>EG: 判断素数</p>
<pre><code>...
isPrime=1         //这里实际上是证伪，所以初始为1，用来避免反复输出，for(i=2;i&lt;x;i++) &#123;                    //掐头去尾是这样的
	if （x%1==0）&#123;
		isPrime=0;          //实际上不break也行，但是会反复赋值
		break;              //continue只会直接跳到下一轮循环
	&#125;
if isPrime==1&#123;            //这里也可以不用isPrime,直接判断i==x
	printf(&quot;是素数\n&quot;);      看有没有完整执行for,是否有break掉。
&#125;else&#123;
printf(&quot;不是素数是\n&quot;);
&#125;
&#125;  
...
</code></pre>
<h5 id="3循环的嵌套"><a class="anchor" href="#3循环的嵌套">#</a> 3. 循环的嵌套</h5>
<p>注意，循环的控制变量必需不一样</p>
<p>比如，判断 100 以内的素数：// 是素数改成 printf</p>
<p>可以在之前的代码上套一个</p>
<pre><code>for (int x=2,x&lt;=100,i++) &#123;&#125;     //记得也要x++
</code></pre>
<p>输出 50 个素数：</p>
<pre><code>int cnt=0;  
while (cnt&lt;50)&#123;&#125;     //输出后记得cnt++
</code></pre>
<p>也可以用 for (x=2;cnt&lt;50;x++) // 这时删掉最后的 x++</p>
<p>EX. 接力 break:<br />
 这需要一个变量（exit）, 开始是 1，当满足条件时将其赋值为 1，随后多个 break 加上 if，判断 exit 是否为 1（这是为了防止未完成就 break）</p>
<p>也可以使用 goto, 用法和命令行差不多，但是定义标签时的：在后面。</p>
<p>这玩意儿最好只用在快速跳出多个循环（要不然乱跳容易乱）</p>
<h4 id="八逻辑运算条件运算"><a class="anchor" href="#八逻辑运算条件运算">#</a> 八。逻辑运算 / 条件运算 /，</h4>
<h5 id="1逻辑运算"><a class="anchor" href="#1逻辑运算">#</a> 1. 逻辑运算</h5>
<p><strong>运算符：</strong></p>
<p>！：非！a：是 a 就 false，不是则 true</p>
<p>&amp;&amp;：与           全部 true 则 true</p>
<p>||：或             一个 true 即可</p>
<p><strong>优先级：</strong></p>
<p>()&gt; ! &gt; 关系运算 &gt; &amp;&amp; &gt; || &gt; 赋值运算</p>
<p><strong>方向：</strong></p>
<p>自左向右，如果已经不成立，就不会接下去判断，所以，赋值运算不要写到里面，可能不会执行，即发生<strong>短路</strong>。</p>
<h5 id="2条件运算"><a class="anchor" href="#2条件运算">#</a> 2. 条件运算</h5>
<p><strong>运算符：</strong></p>
<p>(条件) <strong>?</strong> 条件满足时的值 <strong>:</strong> 条件不满足的时候的值  // 相当于 if,else</p>
<p><strong>优先级：</strong></p>
<p>只大于赋值运算</p>
<p>嵌套条件表达式：</p>
<p>自右向左结合（快跑，没有可读性的玩意儿）</p>
<h5 id="3逗号表达式"><a class="anchor" href="#3逗号表达式">#</a> 3. 逗号表达式</h5>
<p>优先级：</p>
<p>最低，比赋值还低，要用到必需通过括号提升优先级</p>
<p>运算方式：</p>
<p>取右边值，比如 a=(1,2), 此时 a=2。</p>
<p>一般不运算，平常在 for 中来加入多个每轮动作（也不是运算.jpg）</p>
<h1 id="ii函数与数组"><a class="anchor" href="#ii函数与数组">#</a> Ⅱ. 函数与数组</h1>
<h3 id="函数"><a class="anchor" href="#函数">#</a> 函数</h3>
<p><strong>// 为了避免重复代码（同时方便维护），或者精简主函数</strong></p>
<h4 id="1定义函数"><a class="anchor" href="#1定义函数">#</a> 1. 定义函数</h4>
<p>一般来说，main 函数写在最下面，因为编译器是自上而下看的，否则有可能会编译不通过（这看编译器），如果一定要 main 在前面，可以先来个函数原型声明</p>
<p>//(其实就是将函数大括号以外的部分复制一份，加个封号然后单独放在 main 函数前面（事实上可以写在里面，原型声明里也可以不用写或乱写参数名称，只要类型定义是一样的就行（不建议））。定义的部分一定要和声明一致，否则 error，如果不声明，且定义部分在 main 函数下面，那么有些编译器会猜测该函数的返回类型，如果和下面实际定义不相同，有可能也会抛出 error (发生类型冲突))//</p>
<blockquote>
<p>函数原型声明不能冲突，但是可以放空，表示不确定，这时假设与实际冲突，会按照实际。</p>
<p>（这样做会没有对输入类型的检查，可以在 double 中传 int, 不会报错但是值不对，如果确实没有，加 void）</p>
<p>函数中不能定义函数，但可以原型声明。</p>
</blockquote>
<p>int (返回类型) hanshuming (函数名) ()(参数表){</p>
<blockquote>
<p>// 定义函数还可以用 void (中文意是没有)，表示没有返回值，int 有返回值，return 必需带值，size_t 就是 unsign int 类型</p>
<p>// 参数表里逗号分割，看到这个就可以断定这段代码是函数，所以即使是空的也要有，输入时是按顺序复制的</p>
</blockquote>
<p>函数体</p>
<p>return 变量</p>
<blockquote>
<p>// 返回主函数的结果 int 就是说这里 return 的变量是 int 类型</p>
</blockquote>
<p>}</p>
<p>调用时写为:</p>
<p>hanshuming (变量) <a href="%E5%8F%AA%E6%9C%89%E5%A3%B0%E6%98%8E%E8%A6%81%E5%8A%A0%EF%BC%8C%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89%E4%B8%8D%E7%94%A8"><strong>;</strong></a></p>
<p>// 即使不输入什么值，也要括号，否则会 warnning</p>
<blockquote>
<p>return:</p>
<p>1. 停止函数执行，并返回值</p>
<p>2. 返回一个表达式</p>
<p>#一个函数中可以有多个 return 语句，这会导致不是单一出口</p>
<p>调用有返回的函数却不赋值也是可以的，不会警告或报错。</p>
<p>当然，没返回的肯定不能赋值</p>
</blockquote>
<h4 id="2参数传递"><a class="anchor" href="#2参数传递">#</a> 2. 参数传递</h4>
<p>可以传递：</p>
<p>字面量，变量，函数返回值，计算结果</p>
<blockquote>
<p>有强制类型转换，如果声明的参数是 int，传入的是 double, 这个 double 会变成 int (warning)，反之也是</p>
</blockquote>
<p>C 语言只能传值，而不能是变量 (即使是指针，实际上也只是传了个地址数据，也不是把指针本身传递过去)</p>
<p>形式参数与实际参数</p>
<p>函数声明的就是形式参数，实际参数是你调用时传过去的数据 (不是变量)</p>
<p>本地变量 (在函数内部定义的变量就是这个函数的本地变量，包括参数)（局部变量 / 自动变量）</p>
<p>每次函数运行会产生独立变量空间（栈帧？）</p>
<p>变量的生存期和作用域：</p>
<p><img loading="lazy" data-src="1728559512145.png" alt="1728559512145" /></p>
<p>注意：C 语言没有 jacvascript 的闭包特性，所以完全不能跨。</p>
<p><img loading="lazy" data-src="1728559884799.png" alt="1728559884799" /></p>
<p>在 {} 中定义的参数，生存期和作用域也仅限于 {} 中这里即使在 else 中，也不能访问。</p>
<p>如果是 [static]( 静态存储期 ，全局变量默认有。定义这个，只能改变生存期，不能改作用域，该不可见还是不可见。它的作用在于当这个函数被多次调用时，它的值不会被初始化（不在栈中）), 生存期会变成整个程序，但是作用域没变化</p>
<p>局部变量优先原则：当在函数中的<a href="if%E8%AF%AD%E5%8F%A5%E4%B9%8B%E7%B1%BB%E7%9A%84">其他类型</a>的 {} 中定义一个在之外定义过的变量，在 {} 中出现，调用的是其中定义的那个，不是原有，比如：</p>
<p><img loading="lazy" data-src="1728565695161.png" alt="1728565695161" /></p>
<p>直接写一个<a href="%E5%9D%97"> {}</a> 一般用于调试</p>
<p>这里输出的两个 a 不一样</p>
<p><img loading="lazy" data-src="1728565791256.png" alt="1728565791256" /></p>
<h3 id="数组"><a class="anchor" href="#数组">#</a> 数组</h3>
<h4 id="1定义数组"><a class="anchor" href="#1定义数组">#</a> 1. 定义数组</h4>
<p>类型 数组名 [元素个数]   eg.int num [<a href="%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%BB%99%E5%A4%A7%E5%B0%8F">100</a>]     // 索引从 0 开始是第一个，所以只有 0~99</p>
<p>赋值：</p>
<p><img loading="lazy" data-src="1728786107668.png" alt="1728786107668" /></p>
<p>前面一种写法仅限 C99</p>
<p><strong>定义后必需遍历数组初始化</strong></p>
<blockquote>
<p>C 中有个特殊写法，就是 count [number]={0}, 效果和遍历写 0 是一样的</p>
</blockquote>
<p>输出时也是循环遍历</p>
<p><strong>集成化初始时的定义：</strong></p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">&#125;</span>      <span class="token comment">// 没有得到值的，都是 0；没有指定索引的，顺延上一个</span></pre></td></tr></table></figure><p>例题：<a href="%E5%8F%8D%E6%AD%A3%E4%BD%A0%E7%9F%A5%E9%81%93%E5%9C%A8%E5%93%AA%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84">统计数组</a></p>
<h4 id="2数组运算"><a class="anchor" href="#2数组运算">#</a> 2. 数组运算</h4>
<p>要改变数组中的某一个，使用 search 函数</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre>loc<span class="token operator">=</span><span class="token function">search</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>a<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 不要 []</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">if</span> <span class="token punctuation">(</span>loc<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>          <span class="token comment">// 这个函数没找到会返回 - 1，实际上是初始值，这个函数遍历了每个位置，有就加 1</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d在第%d个位置上\n"</span>，x<span class="token punctuation">,</span>loc<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 得到的其实是索引，不是位置，因为初始不是 0</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>search () 要提供大小，其实是因为数组作为函数参数时，是作为指针，只传了第一个元素的地址</p>
<h4 id="3数组的大小"><a class="anchor" href="#3数组的大小">#</a> 3. 数组的大小</h4>
<p>sizeof 数组 ：得到字节数（对于 int，/4 才是数组内元素的数字）</p>
<p>对于任意类型，可以用：</p>
<blockquote>
<p>sizeof(a)/sizeof(a[0])</p>
</blockquote>
<h4 id="4数组的赋值"><a class="anchor" href="#4数组的赋值">#</a> 4. 数组的赋值</h4>
<p>数组变量本身不能被赋值，也不能将<a href="%E6%98%AF%E4%B8%AAconst">数组赋值给数组</a></p>
<p>只能<a href="%E4%B8%80%E8%88%AC%E9%83%BD%E7%94%A8for,%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%88%B0%3C%E9%95%BF%E5%BA%A6">遍历</a>：</p>
<p><img loading="lazy" data-src="1728788625234.png" alt="1728788625234" /></p>
<p>素数还有一种求法（但是看起来比之前的更长，所以没写在那个 cpp 里面）</p>
<p><img loading="lazy" data-src="1728790633321.png" alt="1728790633321" /></p>
<blockquote>
<p>当发现一个素数时，将他加到 prime 里面去，用 cnt++ 就是可以先写入这个位置，再移到下一个，这样可以从第一个开始写，这是因为非素数都可以由比他小的素数乘以某个数得到。</p>
</blockquote>
<p>// 那个 (i+1)%5 是为了控制一行输出 5 个</p>
<p>其他算法：</p>
<p><img loading="lazy" data-src="1728791561052.png" alt="1728791561052" /></p>
<p>就是每使用一个数，就在数组中排除它的倍数</p>
<p>就是：</p>
<p><img loading="lazy" data-src="1728791648318.png" alt="1728791648318" /></p>
<p>// 赋值为 0 表示不是素数，每个数都判断过去是否是它的倍数</p>
<p>// 第一个 i 用于初始化，后面拿来遍历输出</p>
<h4 id="5二维数组"><a class="anchor" href="#5二维数组">#</a> 5. 二维数组</h4>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span>  <span class="token comment">// 一般认为是三行五列（这是内存中的放法）, 不能 a [i,j]，这样里面是逗号表达式，实际上是 a [j]</span></pre></td></tr><tr><td data-num="2"></td><td><pre>集成化初始定义：</pre></td></tr><tr><td data-num="3"></td><td><pre>    a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">&#125;</span>   <span class="token comment">// 内存中都是直接填的，所以写成一维数组也可以</span></pre></td></tr></table></figure><h4 id="6字符数组与字符串"><a class="anchor" href="#6字符数组与字符串">#</a> 6. 字符数组与字符串</h4>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> word<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token char">'H'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'o'</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 字符数组</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">char</span> word<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token char">'H'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'o'</span><span class="token punctuation">,</span><span class="token char">'\0'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 字符串，本质上还是字符数组，C 语言中实际上没有叫字符串的东西</span></pre></td></tr><tr><td data-num="3"></td><td><pre>或者</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">char</span> word<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token char">'H'</span><span class="token punctuation">,</span><span class="token char">'e'</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">,</span><span class="token char">'o'</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre>字符串就是以<span class="token number">0</span>结尾的字符，它表示字符串的结束（不算在字符串长度中，但是占空间<span class="token punctuation">(</span>有索引<span class="token punctuation">)</span>），如果要读入特定个数，记得位数<span class="token operator">+</span><span class="token number">1</span>，留给<span class="token number">0</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   特殊的：</pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">char</span> word<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span>是一个空字符串“\<span class="token number">0</span>”，而不是普通的字符数组</pre></td></tr></table></figure><h5 id="字符串函数stringh"><a class="anchor" href="#字符串函数stringh">#</a> 字符串函数 &lt;string.h&gt;</h5>
<p>可以对普通的字符数组操作</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">函数 &amp; 目的</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾，作为返回值。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度 (不包括结尾 0, 用 char 时 sizeof 就包括，其他类型不用 sizeof，单位不一样)</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。空格，结尾的 \0 也会算进去，实际上这个函数就是挨个比较，不相等时输出这两者之间的差值。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody>
</table>
<h6 id="strcmp"><a class="anchor" href="#strcmp">#</a> strcmp:</h6>
<p>它的原型，可以是：</p>
<p><img loading="lazy" data-src="1729430901698.png" alt="1729430901698" /></p>
<h6 id="strcpy"><a class="anchor" href="#strcpy">#</a> strcpy:</h6>
<p>因为有时不知道这个指针的作用域，防止突然消失，拷贝一份</p>
<pre><code>char *strcpy(char *restrict dst,const char *restrict src);
//restrict表明src和dst不重叠（C99），否则会指向同一个地方
</code></pre>
<p><strong>这个函数会返回 dst 值</strong></p>
<p>使用时要申请内存:</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>dst <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">// 为 \0 提供空间</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token function">strcpy</span><span class="token punctuation">(</span>dst<span class="token punctuation">,</span>src<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">free</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span></pre></td></tr></table></figure><p>它的原型是：</p>
<p><img loading="lazy" data-src="1729434003609.png" alt="" /></p>
<p>然后可以传入俩数组（代码里的 const 防止自赋值（指向同地址））</p>
<p>rest 应该是 ret, 这是因为此时的 dst 指向最后的元素，不能直接返回它</p>
<p>要先用 ret 记录好初始位置</p>
<h6 id="strchr"><a class="anchor" href="#strchr">#</a> strchr:</h6>
<p>还有一个 strrchr 表示从右边开始找</p>
<p>如果要找第二个：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"hello"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span><span class="token function">strchr</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>p <span class="token operator">=</span> <span class="token function">strchr</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这表示从第一个‘l’后一个开始找</span></pre></td></tr></table></figure><p>输出找到的字符前的一段，可以：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment">//malloc 返回指针 + 1 也是按类型</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token function">strcpy</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">free</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>后一段：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>  <span class="token comment">// 这只是一个字符数组，这里不能是字符串</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token function">strchr</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token char">'l'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">char</span> c<span class="token operator">=</span><span class="token operator">*</span>p<span class="token punctuation">;</span>   <span class="token comment">// 暂存原来的值</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>t<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token function">strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token function">strcpy</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 将被提前结束的 s 字符数组 copy</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token operator">*</span>p<span class="token operator">=</span>c         <span class="token comment">// 将 s 数组还原</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token function">free</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这是因为<strong>字符串函数的操作都是以 \0 作为结束</strong>，所以这里实际上是提前结束了 s 字符串</p>
<h6 id="strstr"><a class="anchor" href="#strstr">#</a> strstr:</h6>
<p>还有 strcasestr (不区分大小写的查找)</p>
<p><strong>基本格式</strong>：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strstr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s1<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strcasestr</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span>s1<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr></table></figure><h5 id="字符串变量字面量"><a class="anchor" href="#字符串变量字面量">#</a> 字符串变量 “字面量”</h5>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span><span class="token string">"Hello"</span><span class="token string">"World"</span>   </pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">/* 实际上是六个字节，因为编译器会自动加 \0。连续的字符串会自动拼成一个</pre></td></tr><tr><td data-num="3"></td><td><pre>等价于。这种写法等同于上面那个字符串的写法（编译后）。*/</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span><span class="token string">"Hello\</pre></td></tr><tr><td data-num="5"></td><td><pre>World"</span>   <span class="token comment">// 注意，这样上下俩行的连接会带上 Tab, 这样防止太长，不好看。</span></pre></td></tr></table></figure><p>但是<strong>不能用字符串来运算</strong></p>
<p>字符串数组前<strong>默认有 const</strong>, 不能修改</p>
<p>在编译时就已经确定，如果存在字面量相同的，那么会指向同一个地方</p>
<p>想要修改，就只能是普通的字符数组（实际上它们储存的位置都不一样）</p>
<p><img loading="lazy" data-src="1729425745879.png" alt="1729425745879" /></p>
<p><strong>char * 不一定是指向字符串，它也可以用来指向普通的字符数组，</strong></p>
<p><strong>用它来直接定义的，一定是字符串（这一句必需初始化，否则只是普通的指针）。</strong>（不能是空指针）</p>
<p>字符串数组输出时，用 % s</p>
<blockquote>
<p>一个 % s 只会读到空格前，继续输出才行。</p>
<p>// 这是不安全的，因为不知道实际输入可能有多长，可能发生数组越界</p>
<p>限制输入可以用 %7s (表示最多读 7 个，多余的会放到下一个 scanf（如有），这意味着可以不用回车同时输入上下多个 scanf), 但是若某一个要输入的长度小于 7，必需在输入完这个后回车再继续</p>
</blockquote>
<h6 id="main函数的参数"><a class="anchor" href="#main函数的参数">#</a> main 函数的参数：</h6>
<p><img loading="lazy" data-src="1729428005682.png" alt="1729428005682" /></p>
<p>argc [0]: 一定是 a.out（该程序名）, 程序刚开始时的输入会放到后面（空格分隔）</p>
<p><img loading="lazy" data-src="1729428257169.png" alt="1729428257169" /></p>
<p>这是使用符号链接来启动程序（符号版快捷方式？）</p>
<h1 id="iii不知道是什么"><a class="anchor" href="#iii不知道是什么">#</a> Ⅲ. 不知道是什么</h1>
<h4 id="一辗转相除法"><a class="anchor" href="#一辗转相除法">#</a> 一。辗转相除法</h4>
<p>(更为高效)</p>
<p>算法内容：</p>
<p>如果 b=0，计算结束，a 就是最大公约数，否则，计算 a 除以 b 的余数，让 a=b, 而 b</p>
<p>等于那个余数，回到第一步</p>
<p>演示：</p>
<p>a	b	t</p>
<p>12   18   12           // 这里实现了交换</p>
<p>18    12    6</p>
<p>12     6     0</p>
<p>6        0</p>
<p>所以，最大公约数是 6</p>
<h1 id="iv指针"><a class="anchor" href="#iv指针">#</a> Ⅳ.<a href="%E6%B0%B4%E5%86%B7"> 指针</a></h1>
<h1 id="从入门到放弃"><a class="anchor" href="#从入门到放弃">#</a> 从入门到<a href="%E7%90%86%E8%B5%94">放弃</a></h1>
<h3 id="1取址符"><a class="anchor" href="#1取址符">#</a> 1. 取址符 (&amp;)</h3>
<pre><code>int i=&amp;i    //会有warning,强制类型转换可以消除
//在64位下typeof(&amp;i)是8个字节，32位下和int一样4字节
地址输出用%p
</code></pre>
<p>取地址不能有<strong>运算</strong></p>
<p>数组的指针默认是指向第一个元素的地址，数组在内存中是连续的。</p>
<blockquote>
<p>数组越界，要传递数组大小，就是因为数组本身就是一个指针，没有边界检查。</p>
</blockquote>
<h3 id="2指针类型的变量"><a class="anchor" href="#2指针类型的变量">#</a> 2. 指针类型的<strong>变量</strong></h3>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i    <span class="token comment">//p 在内存中得到的是 i 的地址，称为 p 指向 i</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">,</span>q和<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span>q 是一样的，此时q都是普通的<span class="token keyword">int</span>  <span class="token comment">// 不存在 int * 类型！！</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    定义只再次使用<span class="token operator">*</span>p就是解引用，值为指向的地址的内容这里类型就是<span class="token keyword">int</span>（每次都要）。</pre></td></tr></table></figure><p><img loading="lazy" data-src="1728812248575.png" alt="1728812248575" /></p>
<p>*p 就是 i, 这样就可以访问外面的变量</p>
<p>scanf 就是把你传入的数据写到那个变量的地址上，如果不加 &amp;，会把变量名当作地址，写到别的地方去（没有类型检查）</p>
<h3 id="3指针使用"><a class="anchor" href="#3指针使用">#</a> 3. 指针使用</h3>
<h4 id="1在函数中交换变量"><a class="anchor" href="#1在函数中交换变量">#</a> 1. 在函数中交换变量</h4>
<p>使用 * 变量就可以间接对 main 函数的变量改变</p>
<p><img loading="lazy" data-src="1728812654340.png" alt="1728812654340" /></p>
<p><strong>指针常用于返回值，尤其是多个 (return 只能返回一个)</strong></p>
<p><strong>为了区分返回，函数返回状态值，指针返回数据值</strong> (所以最后常来 return 0)</p>
<p>注意：</p>
<p><em><strong>*p 必须先指向一个变量，再 * p 赋值，否则那个值会被当成是地址</strong></em></p>
<h4 id="2传入数组"><a class="anchor" href="#2传入数组">#</a> 2. 传入数组</h4>
<p>传入的实际上不是数组，而是指向这个数组的指针 (C 语言中只能传数值是这样的)</p>
<p>函数参数表中的数组，实际上是个指针，在 [] 中写东西，是完全没有用的</p>
<p>这就是说，你可以直接将数组传入一个指针</p>
<p><img loading="lazy" data-src="1728813490503.png" alt="1728813490503" /></p>
<p>数组变量是一个特殊的<strong>指针</strong>，单个单元都是<strong>变量</strong>，而且在内存中是连续的（与指针数组不一样）</p>
<p>数组 = const 指针 (所以数组不能互相赋值)</p>
<p>int b []-----int const *b，此时不能用 b++,</p>
<blockquote>
<p>在 C99 中：</p>
<p>被 const 的指针指向的变量可以变，但是不能是通过 const 指针</p>
</blockquote>
<pre><code>int i;
const int* p1 = &amp;i;    //实际上是const *p,也就是*p/i（解引后的值）不能改，但是p（地址）可以改
int const* p2 = &amp;i;    //同上
int *const p3 = &amp;i;    //p（地址）不能改，但是*p/i可以
</code></pre>
<p>const int b []: 表示里面的所有都是常量，这可以在变量原型中写，就不会改变传入数组的值</p>
<h4 id="3指针运算"><a class="anchor" href="#3指针运算">#</a> 3. 指针运算</h4>
<h5 id="-"><a class="anchor" href="#-">#</a> +，-</h5>
<p>p++, 实际上是加了一个类型的大小 (+1 就是加一个类型大小，sizeof)</p>
<p>*p++(常用于数组类的连续操作)： <code>++</code>  的优先级比解引用操作符  <code>*</code>  的优先级高。在表达式  <code>*p++</code>  中， <code>++</code>  操作符会先于  <code>*</code>  操作符被执行。这意味着  <code>p</code>  指针首先会增加，然后  <code>*</code>  操作符会解引用增加后的指针。</p>
<p>但是，由于  <code>p++</code>  是一个后缀递增操作符，它返回的是递增前的指针值。所以，即使  <code>p</code>  指针在  <code>*</code>  操作之前已经递增了， <code>*p++</code>  表达式仍然会返回递增前的指针指向的值。</p>
<p>人话：表达式的值还是 * p, 但是这句之后指针指向 *(p+1)</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token operator">*</span>q<span class="token operator">=</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">*</span><span class="token punctuation">(</span>q<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">=</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>   <span class="token comment">//* 是单目运算符，所以加 ()</span></pre></td></tr><tr><td data-num="2"></td><td><pre>指针也可以相减，是两者之间的距离（地址差<span class="token operator">/</span><span class="token keyword">sizeof</span>）</pre></td></tr></table></figure><h5 id="其他运算"><a class="anchor" href="#其他运算">#</a> 其他运算</h5>
<p>&lt;，&lt;=，==，&gt;，&gt;=，!=(地址大小比较，数组是递增排列的)</p>
<h5 id="0地址"><a class="anchor" href="#0地址">#</a> 0 地址</h5>
<p><img loading="lazy" data-src="1728820093755.png" alt="1728820093755" /></p>
<p>所有进程都有 0 地址（都是虚拟地址），也是不能写的，有的系统，不能读。</p>
<p>特殊事情包括：1. 初始化（没赋值就崩溃）</p>
<p>​                           2. 返回值（这事成不了！）</p>
<p>NULL: 必须全大写，有的编译器只能用 NULL，0 和 NULL 反而不一样</p>
<h5 id="赋值"><a class="anchor" href="#赋值">#</a> 赋值</h5>
<p>必需同类型，因为不同类型的 sizeof 不一样。</p>
<h4 id="4指针类型转化"><a class="anchor" href="#4指针类型转化">#</a> 4. 指针类型转化</h4>
<p><img loading="lazy" data-src="1728821034165.png" alt="1728821034165" /></p>
<p>注：强制类型转化的作用都只限于该句</p>
<h4 id="5指针用处"><a class="anchor" href="#5指针用处">#</a> 5. 指针用处</h4>
<p><img loading="lazy" data-src="1728821145218.png" alt="1728821145218" /></p>
<h3 id="4动态内存分配"><a class="anchor" href="#4动态内存分配">#</a> 4. 动态内存分配</h3>
<p>1.malloc()</p>
<p>C99 之前不能用变量定义数组大小，所以：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//malloc, 用于分配内存，需要 & lt;stdlib.h></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">// 用法：</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span>    <span class="token comment">// 不能传递类型，所以 sizeof (以字节为单位)，返回的是 void*,(int*）// 上面就是指针赋值，前面用于指定类型 (这样才能赋值)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                       <span class="token comment">// 就是在转化</span></pre></td></tr><tr><td data-num="5"></td><td><pre>然后就可以当数组了</pre></td></tr></table></figure><p>如果申请空间失败，会返回 0 或者 NULL，还能用于推出循环，比如</p>
<p><img loading="lazy" data-src="1728821974878.png" alt="1728821974878" /></p>
<p><strong>会报错，但是不会终止程序，还会向下进行。</strong></p>
<p>2.free()</p>
<p>只能还申请空间 (不是申请的不行) 的首地址，否则会报错并终止（有运算也地搞回来）</p>
<p>free (NULL)：什么事情都不会发生，因为指针一般习惯上会初始化为 0，要是没用到，也不会报错</p>
<p><strong>切记：malloc () 最后一定要接 free ()</strong>, 但是不要再次 free</p>
<h3 id="extra"><a class="anchor" href="#extra">#</a> EXTRA</h3>
<p>来自菜鸟教程 (?)</p>
<h4 id="指针数组"><a class="anchor" href="#指针数组">#</a> 指针数组：</h4>
<p>把 <strong>ptr</strong> 声明为一个数组，由 MAX 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   <span class="token keyword">int</span>  var<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">[</span>MAX<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>var<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 赋值为整数的地址 */</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Value of var[%d] = %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">*</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>还可以有字符串指针数组</pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"Hello"</span><span class="token punctuation">,</span><span class="token string">"World"</span><span class="token punctuation">,</span><span class="token string">"aadfdfefcrverg"</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token comment">//a[1]=Hello,a[2]=World...</span></pre></td></tr></table></figure><p>也可以用一个指向字符的指针数组来存储一个字符串列表，如下：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">const</span> <span class="token keyword">int</span> MAX <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>names<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>       <span class="token string">"Zara Ali"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="8"></td><td><pre>       <span class="token string">"Hina Ali"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>       <span class="token string">"Nuha Ali"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>       <span class="token string">"Sara Ali"</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Value of names[%d] = %s\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> names<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>这跟普通数组相比，地址是不连续的，运算方法一样。</p>
<p>字符指针数组可以达到和枚举相似的效果：</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token string">"apple"</span><span class="token punctuation">,</span><span class="token string">"bpple"</span><span class="token punctuation">,</span><span class="token string">"cpple"</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> a<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span>s<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">// 这样就可以将数字 (作为索引) 对应上字符串</span></pre></td></tr></table></figure><h4 id="指向指针的指针"><a class="anchor" href="#指向指针的指针">#</a> 指向指针的指针：</h4>
<p>纯套娃，定义就是 int **var 等</p>
<p>这种变量解引用一次后得到的就是被指向的指针，仍然是个地址</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre> </pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token keyword">int</span>  V<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token keyword">int</span>  <span class="token operator">*</span>Pt1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token keyword">int</span>  <span class="token operator">*</span><span class="token operator">*</span>Pt2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   V <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   <span class="token comment">/* 获取 V 的地址 */</span></pre></td></tr><tr><td data-num="10"></td><td><pre>   Pt1 <span class="token operator">=</span> <span class="token operator">&amp;</span>V<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token comment">/* 使用运算符 &amp; 获取 Pt1 的地址 */</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   Pt2 <span class="token operator">=</span> <span class="token operator">&amp;</span>Pt1<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   <span class="token comment">/* 使用 pptr 获取值 */</span></pre></td></tr><tr><td data-num="14"></td><td><pre>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"var = %d\n"</span><span class="token punctuation">,</span> V <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Pt1 = %p\n"</span><span class="token punctuation">,</span> Pt1 <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*Pt1 = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>Pt1 <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Pt2 = %p\n"</span><span class="token punctuation">,</span> Pt2 <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"**Pt2 = %d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>Pt2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="返回指针的函数"><a class="anchor" href="#返回指针的函数">#</a> <strong>返回指针的函数：</strong></h4>
<p>定义：int * myFunction ()</p>
<p>C 语言不支持在调用函数时返回局部变量的地址，除非定义局部变量为 <strong>static</strong> 变量</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span> </span></pre></td></tr><tr><td data-num="4"></td><td><pre> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">/* 要生成和返回随机数的函数 */</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span> <span class="token function">getRandom</span><span class="token punctuation">(</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   <span class="token keyword">static</span> <span class="token keyword">int</span>  r<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>             <span class="token comment">// 这样结束后只是不可见，不会销毁，可以传递其值</span></pre></td></tr><tr><td data-num="9"></td><td><pre>   <span class="token keyword">int</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> </pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token comment">/* 设置种子 */</span></pre></td></tr><tr><td data-num="12"></td><td><pre>   <span class="token function">srand</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//srand () 用于初始化 rand (),null 其实是默认</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token comment">// 获取时间是为了保障 rand () 的随机，否则多次调用时可能会重复</span></pre></td></tr><tr><td data-num="14"></td><td><pre>   <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre> </pre></td></tr><tr><td data-num="19"></td><td><pre>   <span class="token keyword">return</span> r<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> </pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token comment">/* 要调用上面定义函数的主函数 */</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>   <span class="token comment">/* 一个指向整数的指针 */</span></pre></td></tr><tr><td data-num="26"></td><td><pre>   <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>   <span class="token keyword">int</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre> </pre></td></tr><tr><td data-num="29"></td><td><pre>   p <span class="token operator">=</span> <span class="token function">getRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>   <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>   <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>       <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"*(p + [%d]) : %d\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="34"></td><td><pre> </pre></td></tr><tr><td data-num="35"></td><td><pre>   <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="函数指针"><a class="anchor" href="#函数指针">#</a> 函数指针：</h4>
<p>定义</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fun_ptr<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 声明一个指向同样参数、返回值的函数指针类型</span></pre></td></tr><tr><td data-num="2"></td><td><pre>fun_ptr a<span class="token operator">=</span>max<span class="token punctuation">;</span>  <span class="token comment">// 声明这个类型，只是为了在这句定义里检查类型是否符合，其实就是类型检查，还有就是方便修改，不用一个一个改类型，同时方便创建</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr></table></figure><h4 id="回调函数"><a class="anchor" href="#回调函数">#</a> 回调函数：</h4>
<p><strong>函数指针作为某个函数的参数</strong></p>
<p>可以根据不同的条件调用不同的函数，比较灵活</p>
<figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span>  </span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span></pre></td></tr><tr><td data-num="3"></td><td><pre> </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">populate_array</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>array<span class="token punctuation">,</span> <span class="token class-name">size_t</span> arraySize<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>getNextValue<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arraySize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">getNextValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> </pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 获取随机值</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">int</span> <span class="token function">getNextRandomValue</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">return</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> </pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token keyword">int</span> myarray<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">/* getNextRandomValue 不能加括号，否则无法编译，因为加上括号之后相当于传入此参数时传入了 int （函数的返回值）, 而不是函数指针 */</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token function">populate_array</span><span class="token punctuation">(</span>myarray<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> getNextRandomValue<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> myarray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i></span><span class="text">編集日</span><time title="修正日：2025-03-08 17:08:19" itemprop="dateModified" datetime="2025-03-08T17:08:19+08:00">2025-03-08</time></span></div><div id="copyright"><ul><li class="author"><strong>著者：</strong>这玩意儿是昵称<i class="ic i-at"><em>@</em></i>这就是--Potato</li><li class="link"><strong>記事へのリンク：</strong><a href="https://zhewanyiershinicheng.github.io/2024/10/14/C%E7%AC%94%E8%AE%B01ultrasuper/" title="C笔记ultra">https://zhewanyiershinicheng.github.io/2024/10/14/C笔记1ultrasuper/</a></li><li class="license"><strong>著作権表示：</strong>このブログ内のすべての記事は、特別な記載がない限り <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</a> の下のライセンスで保護されています。</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2024/10/14/IDA%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="prev" itemprop="url" title="IDA" style="background-image: linear-gradient(to bottom right, #b7e6b4, #b7dcf6);"><span class="type">前の記事</span><span class="category"><i class="ic i-flag"></i>技术</span><h3>IDA</h3></a></div><div class="item right"><a href="/2024/10/14/C%E7%AC%94%E8%AE%B02SE/" rel="next" itemprop="url" title="C笔记2SE" style="background-image: linear-gradient(to bottom right, #a2f5ce, #ffece5);"><span class="type">次の記事</span><span class="category"><i class="ic i-flag"></i>技术</span><h3>C笔记2SE</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="見出し"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#i%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text"> Ⅰ. 语法（？）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">1.0.0.1.</span> <span class="toc-text"> 一。程序执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8Cprintf-%E4%B8%8Escanf-stdioh"><span class="toc-number">1.0.0.2.</span> <span class="toc-text"> 二.printf 与 scanf              &lt;stdio.h&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97"><span class="toc-number">1.0.0.3.</span> <span class="toc-text"> 三。关系运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E4%BA%94%E5%A4%8D%E5%90%88%E8%B5%8B%E5%80%BC"><span class="toc-number">1.0.0.4.</span> <span class="toc-text"> 三。五. 复合赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F"><span class="toc-number">1.0.0.5.</span> <span class="toc-text"> 四。变量与常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%94%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.0.6.</span> <span class="toc-text"> 五。变量类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E8%B5%B7"><span class="toc-number">1.0.0.7.</span> <span class="toc-text"> 总起</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E6%95%B4%E6%95%B0int%E7%9C%8B%E7%BC%96%E8%AF%91%E5%99%A8%E5%8D%B3%E4%B8%80%E4%B8%AA%E5%AD%97bool"><span class="toc-number">1.0.0.7.1.</span> <span class="toc-text"> 1. 整数（int (看编译器，即一个字)&#x2F;bool）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E6%B5%AE%E7%82%B9%E6%95%B0floatdouble"><span class="toc-number">1.0.0.7.2.</span> <span class="toc-text"> 2. 浮点数（float,double）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E5%AD%97%E7%AC%A6char"><span class="toc-number">1.0.0.7.3.</span> <span class="toc-text"> 3. 字符（char）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-number">1.0.0.7.3.1.</span> <span class="toc-text"> 杂项</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4%E6%8C%87%E9%92%88%E5%8D%95%E7%8B%AC%E6%94%BE%E5%9C%A8%E4%B8%8B%E9%9D%A2"><span class="toc-number">1.0.0.7.4.</span> <span class="toc-text"> 4. 指针（单独放在下面）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.0.7.5.</span> <span class="toc-text"> 5. 自定义类型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.0.0.7.5.1.</span> <span class="toc-text"> 枚举</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.0.0.7.5.2.</span> <span class="toc-text"> 结构体</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ex"><span class="toc-number">1.0.0.7.6.</span> <span class="toc-text"> EX</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ex%E6%95%B4%E6%95%B0%E6%B1%82%E9%80%86"><span class="toc-number">1.0.0.7.6.1.</span> <span class="toc-text"> EX 整数求逆</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#ex%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="toc-number">1.0.0.7.6.2.</span> <span class="toc-text"> EX 类型转化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%ADifswitch"><span class="toc-number">1.0.0.8.</span> <span class="toc-text"> 六。条件判断（if&#x2F;switch）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1if-else"><span class="toc-number">1.0.0.8.1.</span> <span class="toc-text"> 1.if-else</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2switch-case"><span class="toc-number">1.0.0.8.2.</span> <span class="toc-text"> 2.switch-case</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%83%E5%BE%AA%E7%8E%AFforwhile"><span class="toc-number">1.0.0.9.</span> <span class="toc-text"> 七。循环 (for&#x2F;while)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1while"><span class="toc-number">1.0.0.9.1.</span> <span class="toc-text"> 1.while</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2for"><span class="toc-number">1.0.0.9.2.</span> <span class="toc-text"> 2.for</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-number">1.0.0.9.3.</span> <span class="toc-text"> 3. 循环的嵌套</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AB%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97"><span class="toc-number">1.0.0.10.</span> <span class="toc-text"> 八。逻辑运算 &#x2F; 条件运算 &#x2F;，</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">1.0.0.10.1.</span> <span class="toc-text"> 1. 逻辑运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97"><span class="toc-number">1.0.0.10.2.</span> <span class="toc-text"> 2. 条件运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.0.0.10.3.</span> <span class="toc-text"> 3. 逗号表达式</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ii%E5%87%BD%E6%95%B0%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text"> Ⅱ. 函数与数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.0.1.</span> <span class="toc-text"> 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="toc-number">2.0.1.1.</span> <span class="toc-text"> 1. 定义函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">2.0.1.2.</span> <span class="toc-text"> 2. 参数传递</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">2.0.2.</span> <span class="toc-text"> 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84"><span class="toc-number">2.0.2.1.</span> <span class="toc-text"> 1. 定义数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E6%95%B0%E7%BB%84%E8%BF%90%E7%AE%97"><span class="toc-number">2.0.2.2.</span> <span class="toc-text"> 2. 数组运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.0.2.3.</span> <span class="toc-text"> 3. 数组的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.0.2.4.</span> <span class="toc-text"> 4. 数组的赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.0.2.5.</span> <span class="toc-text"> 5. 二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.0.2.6.</span> <span class="toc-text"> 6. 字符数组与字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0stringh"><span class="toc-number">2.0.2.6.1.</span> <span class="toc-text"> 字符串函数 &lt;string.h&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#strcmp"><span class="toc-number">2.0.2.6.1.1.</span> <span class="toc-text"> strcmp:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#strcpy"><span class="toc-number">2.0.2.6.1.2.</span> <span class="toc-text"> strcpy:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#strchr"><span class="toc-number">2.0.2.6.1.3.</span> <span class="toc-text"> strchr:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#strstr"><span class="toc-number">2.0.2.6.1.4.</span> <span class="toc-text"> strstr:</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">2.0.2.6.2.</span> <span class="toc-text"> 字符串变量 “字面量”</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#main%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">2.0.2.6.2.1.</span> <span class="toc-text"> main 函数的参数：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iii%E4%B8%8D%E7%9F%A5%E9%81%93%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.</span> <span class="toc-text"> Ⅲ. 不知道是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95"><span class="toc-number">3.0.0.1.</span> <span class="toc-text"> 一。辗转相除法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#iv%E6%8C%87%E9%92%88"><span class="toc-number">4.</span> <span class="toc-text"> Ⅳ. 指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83"><span class="toc-number">5.</span> <span class="toc-text"> 从入门到放弃</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E5%8F%96%E5%9D%80%E7%AC%A6"><span class="toc-number">5.0.1.</span> <span class="toc-text"> 1. 取址符 (&amp;)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-number">5.0.2.</span> <span class="toc-text"> 2. 指针类型的变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8"><span class="toc-number">5.0.3.</span> <span class="toc-text"> 3. 指针使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BA%A4%E6%8D%A2%E5%8F%98%E9%87%8F"><span class="toc-number">5.0.3.1.</span> <span class="toc-text"> 1. 在函数中交换变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E4%BC%A0%E5%85%A5%E6%95%B0%E7%BB%84"><span class="toc-number">5.0.3.2.</span> <span class="toc-text"> 2. 传入数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-number">5.0.3.3.</span> <span class="toc-text"> 3. 指针运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-"><span class="toc-number">5.0.3.3.1.</span> <span class="toc-text"> +，-</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%BF%90%E7%AE%97"><span class="toc-number">5.0.3.3.2.</span> <span class="toc-text"> 其他运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#0%E5%9C%B0%E5%9D%80"><span class="toc-number">5.0.3.3.3.</span> <span class="toc-text"> 0 地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">5.0.3.3.4.</span> <span class="toc-text"> 赋值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E6%8C%87%E9%92%88%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96"><span class="toc-number">5.0.3.4.</span> <span class="toc-text"> 4. 指针类型转化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E6%8C%87%E9%92%88%E7%94%A8%E5%A4%84"><span class="toc-number">5.0.3.5.</span> <span class="toc-text"> 5. 指针用处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">5.0.4.</span> <span class="toc-text"> 4. 动态内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extra"><span class="toc-number">5.0.5.</span> <span class="toc-text"> EXTRA</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="toc-number">5.0.5.1.</span> <span class="toc-text"> 指针数组：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E6%8C%87%E9%92%88%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">5.0.5.2.</span> <span class="toc-text"> 指向指针的指针：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E6%8C%87%E9%92%88%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.0.5.3.</span> <span class="toc-text"> 返回指针的函数：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">5.0.5.4.</span> <span class="toc-text"> 函数指针：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">5.0.5.5.</span> <span class="toc-text"> 回调函数：</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="関連記事"><ul><li ><a href="/2024/10/11/MySQL/" rel="bookmark" title="MySQL">MySQL</a></li><li ><a href="/2024/10/11/%E6%B1%87%E7%BC%96/" rel="bookmark" title="汇编">汇编</a></li><li ><a href="/2024/10/14/C%E7%AC%94%E8%AE%B02SE/" rel="bookmark" title="C笔记2SE">C笔记2SE</a></li><li  class="active"><a href="/2024/10/14/C%E7%AC%94%E8%AE%B01ultrasuper/" rel="bookmark" title="C笔记ultra">C笔记ultra</a></li><li ><a href="/2024/10/14/IDA%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="bookmark" title="IDA">IDA</a></li><li ><a href="/2024/10/14/HTML/" rel="bookmark" title="HTML">HTML</a></li><li ><a href="/2024/10/14/JavaScript/" rel="bookmark" title="JavaScript">JavaScript</a></li><li ><a href="/2025/01/22/Linux/" rel="bookmark" title="Linux">Linux</a></li><li ><a href="/2025/02/04/SQL%E6%B3%A8%E5%85%A5/" rel="bookmark" title="SQL注入">SQL注入</a></li><li ><a href="/2025/02/05/XSS/" rel="bookmark" title="XSS">XSS</a></li><li ><a href="/2025/02/15/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" rel="bookmark" title="文件上传漏洞">文件上传漏洞</a></li></ul></div><div class="overview panel" data-title="概要"><div class="author" itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><img class="image" loading="lazy" decoding="async" itemprop="image" alt="开船的" src="/assets/avatar.jpg"/><p class="name" itemprop="name">开船的</p><div class="description" itemprop="description">bug依旧很多，反正我忍不了</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">19</span><span class="name">ポスト</span></a></div><div class="item categories"><a href="/categories/"><span class="count">3</span><span class="name">カテゴリ</span></a></div><div class="item tags"><a href="/tags/"><span class="count">4</span><span class="name">タグ</span></a></div></nav><div class="social"><a target="_blank" rel="noopener" href="https://github.com/zhewanyiershinicheng" class="item github" title="https:&#x2F;&#x2F;github.com&#x2F;zhewanyiershinicheng"><i class="ic i-github"></i></a></div><div class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>ホーム</a></li><li class="item dropdown"><a href="#" onclick="return false;"><i class="ic i-feather"></i>投稿</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>アーカイブ</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>カテゴリ</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>タグ</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>フレンド</a></li></div></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2024/10/14/C%E7%AC%94%E8%AE%B02SE/" rel="prev" title="前の記事"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/10/14/IDA%E7%9A%84%E4%BD%BF%E7%94%A8/" rel="next" title="次の記事"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>ランダムな記事</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/%E6%8A%80%E6%9C%AF/" title="カテゴリ技术">技术</a></div><span><a href="/2024/10/14/C%E7%AC%94%E8%AE%B01ultrasuper/">C笔记ultra</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%8A%80%E6%9C%AF/" title="カテゴリ技术">技术</a></div><span><a href="/2024/10/14/JavaScript/">JavaScript</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E5%8F%91%E7%94%B5/" title="カテゴリ发电">发电</a></div><span><a href="/2024/10/11/Web%E6%96%B9%E5%90%91/">web</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%8A%80%E6%9C%AF/" title="カテゴリ技术">技术</a></div><span><a href="/2025/02/05/XSS/">XSS</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%8A%80%E6%9C%AF/" title="カテゴリ技术">技术</a></div><span><a href="/2024/10/14/HTML/">HTML</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/10/11/%E5%9C%9F%E8%B1%86%E7%9B%B4%E6%92%AD%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%81/">土豆直播</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%8A%80%E6%9C%AF/" title="カテゴリ技术">技术</a></div><span><a href="/2025/01/22/Linux/">Linux</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%8A%80%E6%9C%AF/" title="カテゴリ技术">技术</a></div><span><a href="/2025/02/04/SQL%E6%B3%A8%E5%85%A5/">SQL注入</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E7%A6%BB%E8%B0%B1/" title="カテゴリ离谱">离谱</a></div><span><a href="/2024/10/11/%E5%9C%9F%E8%B1%86%E8%B1%86%E8%B1%86%E8%B1%86%E8%B1%86/">土豆豆豆豆豆</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/%E6%8A%80%E6%9C%AF/" title="カテゴリ技术">技术</a></div><span><a href="/2024/10/14/C%E7%AC%94%E8%AE%B02SE/">C笔记2SE</a></span></li></ul></div><div class="rpost pjax"><h2>最近のコメント</h2></div></div><div class="status"><div class="copyright">&copy; 2022 -<span itemprop="copyrightYear">2025</span><span class="with-love"><i class="ic i-sakura rotate"></i></span><span class="author" itemprop="copyrightHolder">开船的 @ chongkai</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i></span><span title="単語の総数">140k 単語</span><span class="post-meta-divider"> | </span><span class="post-meta-item-icon"><i class="ic i-coffee"></i></span><span title="読書の合計時間">2:07</span></div><div class="powered-by">Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & Theme.<a target="_blank" rel="noopener" href="https://github.com/theme-shoka-x/hexo-theme-shokaX/">ShokaX</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL = {
    ispost: true,
        path: `2024/10/14/C笔记1ultrasuper/`,
        favicon: {
        show: `（●´3｀●）やれやれだぜ`,
        hide: `(´Д｀)大変だ！`
    },
    search: {
        placeholder: "検索…",
        empty: "「 ${query} 」については何も見つかりませんでした",
        stats: "${time} ms以内に ${hits} 件の結果が見つかりました"
    },
    copy_tex: false,
    katex: false,
    mermaid: false,
    audio: undefined,
    fancybox: true,
    nocopy: false,
    outime: true,
    template: `<div class="note warning"><p><span class="label warning">記事の適時性の警告</span><br> {{publish}} 日前に公開され、 {{updated}} 日前に最終更新された記事です。 一部情報が変更されている可能性がありますので、ご了承ください。</p></div>`,
    quiz: {
        choice: `選択`,
        multiple: `複数選択`,
        true_false: `正誤`,
        essay: `問答`,
        gap_fill: `空欄`,
        mistake: `間違った答え`
    },
    ignores: [
        (uri) => uri.includes('#'),
        (uri) => new RegExp(LOCAL.path + '$').test(uri),
            []
    ]
};
</script><script src="https://s4.zstatic.net/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8" crossorigin="anonymous" fetchpriority="high"></script><script src="https://s4.zstatic.net/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha384-ZvpUoO&#x2F;+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn&#x2F;6Z&#x2F;hRTt8+pR6L4N2" crossorigin="anonymous" fetchpriority="high"></script><script src="/js/siteInit.js?v=0.4.17" type="module" fetchpriority="high" defer></script></body></html>